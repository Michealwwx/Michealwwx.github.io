<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michaelwwx</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://michaelwwx.top/"/>
  <updated>2017-10-15T14:20:10.353Z</updated>
  <id>http://michaelwwx.top/</id>
  
  <author>
    <name>Michaelwwx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bootStrap</title>
    <link href="http://michaelwwx.top/2017/10/14/bootStrap/"/>
    <id>http://michaelwwx.top/2017/10/14/bootStrap/</id>
    <published>2017-10-14T15:58:09.000Z</published>
    <updated>2017-10-15T14:20:10.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/10/14/bootStrap/a.jpg" alt="post-cover"></p><p>Bootstrap是比较流行的响应式框架,它会根据你的屏幕的大小来调整HTML元素的大小 —— 强调 响应式设计的概念。<br>通过响应式设计，你无需再为你的网站设计一个手机版的。它在任何尺寸的屏幕上看起来都会不错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2017/10/14/bootStrap/a.jpg&quot; alt=&quot;post-cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;Bootstrap是比较流行的响应式框架,它会根据你的屏幕的大小来调整HTML元素的大小 —— 强调 响应式设计的概念。&lt;br&gt;通过响应式设计，你
      
    
    </summary>
    
      <category term="BootStrap" scheme="http://michaelwwx.top/categories/BootStrap/"/>
    
    
      <category term="BootStrap" scheme="http://michaelwwx.top/tags/BootStrap/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis缓存上</title>
    <link href="http://michaelwwx.top/2017/10/14/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8A/"/>
    <id>http://michaelwwx.top/2017/10/14/Mybatis缓存上/</id>
    <published>2017-10-14T15:31:24.000Z</published>
    <updated>2017-10-15T14:19:03.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/10/14/Mybatis缓存上/mybatis.jpg" alt="post-cover"><br>Mybatis的缓存机制</p><p>前言：</p><p>Mybatis包含一个非常强大的查询缓存特性，他可以非常方便的配置和定制。缓存可以极大的提升查询效率。</p><p>Mybatis系统和Hibernate系统类似中定义了两级缓存：</p><p>一级缓存和二级缓存。</p><p>一级缓存（本地缓存），是基于SqlSession级别的缓存，默认情况下，一级缓存是开启的。<br>二级缓存（全局缓存），是基于nameSpace级别的缓存，二级缓存需要手动开启和配置。<br>       为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存。</p><p>一.一级缓存（local cache）</p><p>阅读mybatis源文档总结：<br>（1）一级缓存，即本地缓存，作用域为SqlSession，当Session flush或close后，该Session中的所有Cache将被清空。<br>（2）同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map中，Key：hashCode+查询的SqlId+编写的Sql查询语句+参数<br>（3）一级缓存失效的四种情况<br>        —–不同的SqlSession对于不同的一级缓存。<br>        ——同一个SqlSession但是查询条件不同。<br>        ——同一个SqlSession查询期间执行了一次增删改操作。<br>        ——同一个SqlSession两次查询期间手动清空了缓存。<br>1.1证明一级缓存的存在</p><p>案例：在同一个SqlSession中查询同一个id的Emp对象。</p><pre><code>@Testpublic void TestFirstLevelCache() throws IOException{    SqlSession openSession=this.getSqlSessionFactory().openSession();    try {        EmpMapper empMapper=openSession.getMapper(EmpMapper.class);        Emp emp=empMapper.findEmpById(4);        Emp emp2=empMapper.findEmpById(4);        System.out.println(emp);        System.out.println(emp2);        System.out.println(emp==emp2);    } catch (Exception e) {        e.printStackTrace();    }    finally{        openSession.close();    }}</code></pre><p>结果</p><p>分析：两条查询语句，只发送了一次sql语句，并且两次查询到封装的对象相同，说明第二次查询是从缓存中拿到的。证明了SqlSession级别的缓存存在。</p><p>1.2一级缓存失效的情况</p><p>一级缓存失效的四种情况<br>        —–不同的SqlSession对于不同的一级缓存。<br>        ——同一个SqlSession但是查询条件不同。<br>        ——同一个SqlSession查询期间执行了一次增删改操作。<br>        ——同一个SqlSession两次查询期间手动清空了缓存。</p><p>二.二级缓存</p><p>二级缓存，全局作用域缓存，二级缓存默认不开启，需要手动配置，Mybatis提供了二级缓存接口Cache以及实现。<br>生效：二级缓存只有在SqlSession关闭或提交之后才会生效。<br>原理：在开启了二级缓存的前提下，在一级缓存关闭以后，里面的缓存数据会迁移到二级缓存中。供程序使用。</p><p>2.1使用步骤</p><p>（1）在Mybatis全局配置文件的<settings>节点中配置</settings></p><p><setting name="cacheEnabled" value="true"><br>（2）在相应的Mapper.xml文件中加上<br> <cache eviction="" flushinterval="" readonly size="" type=""></cache><br> 或<cache-ref namespace=""></cache-ref></setting></p><p>cache标签中的属性：</p><p>eviction：缓存回收策略，默认是LRU<br>—LRU—最近最少使用：移除最长时间不被使用的对象。<br>—FIFO–先进先出：按对象加入缓存的顺序来移除它们。<br>—SOFT-软引用：移除基于垃圾回收期状态和软引用规则的对象。<br>—WEAK-弱引用：更积极的移除基于垃圾收集器和弱引用规则的对象。<br>flushInteval：刷新间隔，单位毫秒<br>    默认情况下不设置，即没有刷新间隔，缓存仅仅调用语句时刷新。<br>size：引用数目，正整数<br>—代表缓存最多可以存储多少个对象。<br>readOnly：只读，true/false，默认false<br>—true：只读缓存，会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改。速度快。<br>—false：读写缓存，会利用序列化和反序列来返回缓存对象的拷贝，速度较只读缓存慢，优点是安全。注意，这也就是为什么pojo对象需要实现序列化接口的原因。<br>type:用于自定义缓存类的全类名。</p><p>参照缓存cache-ref中的属性：<br>若想要在命名空间中共享相同的缓存配置，可以使用cache-ref元素来引用另外一个缓存。<br>namespace：表示引用哪个namespace的二级缓存，就将值设置为另外一个缓存的Mapper对象的全类名。</p><p>（3）对相应的Pojo对象实现序列化接口。这个与Cache标签中的readOnly属性的false值相关。</p><p>（4）需要在相应的查询语句中加上  userCache=”true”属性。表示该select语句使用二级缓存。</p><p>2.2整合第三方二级缓存—EhCache</p><p>EhCache是一个纯java的进程内缓存框架，具有快速、精干等特点，同时也是Hibernate中默认的CacheProvider。<br>Mybatis定义了Cache接口方便我们进行自定义扩展。</p><p>步骤：<br>（1）导入Ehcache包，整合Mybatis的jar包，日志包<br> ehcache=core-<em>.jar、mybatis-ehcache-</em>.jar、sl4j-api-<em>.jar、slf4j-log4j-</em>.jar</p><p>（2）编写ehcache.xml,具体可以到Ehcache官网上查看相关文档。</p><p>ehcache.xml</p><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nonamespaceschemalocation="../config/ehcache.xsd"><br> <!-- 磁盘保存路径 --><br> <diskstore path="D:\ehcache"><br><br> <defaultcache maxelementsinmemory="10000" maxelementsondisk="10000000" eternal="false" overflowtodisk="true" timetoidleseconds="120" timetoliveseconds="120" diskexpirythreadintervalseconds="120" memorystoreevictionpolicy="LRU"><br> </defaultcache><br></diskstore></ehcache><!-- 属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目 l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --><p>（3）配置Mapper.xml中的Cache标签中的type属性，该属性的值为</p><p><cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache><br>同样可以配置参照缓存。</p><p>由于Mybatis内容很多，后面会继续更新Mybatis各方面的知识，包括Mybatis原理，Mybatis架构，Mybatis和Redis，memcache的整合等等。<br>本文是源码级别学习Mybatis系列的一节，如果您有兴趣，可以继续关注我哟，如果觉得本文不错，顺手点个赞吧，您的鼓励，是我继续分享知识的强大动力！<br>如果您觉得有不妥或者错误的地方，还请您不吝指教！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2017/10/14/Mybatis缓存上/mybatis.jpg&quot; alt=&quot;post-cover&quot;&gt;&lt;br&gt;Mybatis的缓存机制&lt;/p&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;Mybatis包含一个非常强大的查询缓存特性，他可以非常方便的配置和定制。缓存
      
    
    </summary>
    
      <category term="Mybatis" scheme="http://michaelwwx.top/categories/Mybatis/"/>
    
    
      <category term="Mybatis Cache" scheme="http://michaelwwx.top/tags/Mybatis-Cache/"/>
    
  </entry>
  
  <entry>
    <title>Nosql数据库入门</title>
    <link href="http://michaelwwx.top/2017/08/09/Redis/"/>
    <id>http://michaelwwx.top/2017/08/09/Redis/</id>
    <published>2017-08-09T15:31:24.000Z</published>
    <updated>2017-10-24T13:49:02.576Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/nosql.jpg" alt="post-cover"></p><h1 id="NOSQL入门"><a href="#NOSQL入门" class="headerlink" title="NOSQL入门"></a>NOSQL入门</h1><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>###单机MySQL的时代</p><blockquote><ol><li><p>数据量的总大小一个服务器存不下。</p></li><li><p>数据的索引（B+Tree）空间太大。</p></li><li><p>访问量（读写混合）一个实例不能承受。<br>###Memcached（缓存)+MySQL+垂直拆分<br>发展：随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注于功能上，同时也在追求性能。这时缓存技术的出现有效的缓解了数据库的压力。优化数据库的结构和所有。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大时，多台web机器通过文件缓存不能共享，大量的小文件缓存带来了比较高的IO压力，这是Memcached就自然的成为了非常时尚的技术产品。<br>Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少服务器导致重新hash带来的大量缓存失效的弊端。</p></li></ol></blockquote><p>###MySQL主从读写分离</p><blockquote><p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。<br>MySQL的master-slav模式成为这个时候的网站标配。</p></blockquote><p>###分表分库+水平拆分+MySQL集群</p><blockquote><p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。<br>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大<br>的保证。</p></blockquote><p>###MySQL的扩展性瓶颈</p><blockquote><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p></blockquote><p>###这个时候NOSQL的概念提出</p><blockquote><p>为什么使用NoSQL ?<br>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p></blockquote><p>#NOSQL的介绍</p><p>##NOSQL是什么？</p><blockquote><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，<br>泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p><p>（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p></blockquote><p>##NOSQL能干嘛?</p><p>###易扩展</p><blockquote><p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p><p>###大数据量高性能</p><p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。<br>这得益于它的无关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</p><p>###多种灵活的数据模型<br>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，<br>增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</p><p>###传统RDBMS  VS  NOSQL</p><p><strong>RDBMS</strong><br></p><ol><li>高度组织化结构化数据<br></li><li>结构化查询语言（SQL）<br></li><li>数据和关系都存储在单独的表中。<br></li><li>数据操纵语言，数据定义语言<br></li><li>严格的一致性<br></li><li>基础事务<br></li></ol><p><strong>NoSQL</strong><br></p><ol><li>代表着不仅仅是SQL<br></li><li>没有声明性查询语言<br></li><li>没有预定义的模式<br></li><li>键 - 值对存储，列存储，文档存储，图形数据库<br></li><li>最终一致性，而非ACID属性<br></li><li>非结构化和不可预知的数据<br></li><li>CAP定理<br></li><li>高性能，高可用性和可伸缩性<br></li></ol></blockquote><p>##NOSQL数据库的3V+3高</p><blockquote><p><strong>3V</strong><br><br>大数据时代的3v<br></p><ol><li>海量Volume<br></li><li>多样Variety<br></li><li>实时Velocity<br></li></ol><p><strong>3高</strong><br></p><ol><li>高并发<br></li><li>高可扩<br></li><li>高性能<br></li></ol></blockquote><p>#NOSQL数据库的分类</p><p>##KV键值<br>典型介绍<br></p><ol><li>新浪：BerkeleyDB+redis<br></li><li>美团：redis+tair<br></li><li>阿里、百度：Memcache+redis<br></li></ol><p>##文档型数据库（bson格式比较多）<br>典型介绍：MongoDB</p><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>##列存储数据库<br>Cassandra、HBASE<br><br>分布式文件系统</p><p>##图关系数据库<br>注意：图关系数据不是放图形的，放的是关系，比如朋友圈社交网络，广告推荐系统。<br><br>典型：Neo4j，infoGrid</p><p>#分布式数据库中CAP原理+BASE</p><p>##关系型数据库的ACID<br></p><ol><li>A:Atomicity原子性<br></li><li>C:Consistency一致性<br></li><li>I:Isolation独立性<br></li><li>D：Durability持久性<br><br>##分布式数据CAP原理：</li><li>C:Consistency（强一致性）</li><li>A：Availablity（可用性）</li><li>P:Partition tolerance（分区容错性）</li></ol><p>###CAP的3进2<br>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。<br>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<strong>分区容忍性</strong>是我们必须需要实现的</p><p>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。<br></p><ol><li>CA 传统Oracle数据库<br></li><li>AP 大多数网站架构的选择<br></li><li>CP Redis、Mongodb<br></li></ol><p>注意：分布式架构的时候必须做出取舍。<br>一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。<br>因此牺牲C换取P，这是目前分布式数据库产品的方向</p><p>一致性与可用性的决择<br>对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p><p>####数据库事务一致性需求<br>　　很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</p><p>####数据库的写实时性和读实时性需求<br>　　对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p><p>####对复杂的SQL查询，特别是多表关联查询的需求<br>　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p><p>##BASE<br>BASE是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p><p>BASE其实是下面三个术语的缩写：<br></p><ol><li>基本可用（Basically Available）<br></li><li>软状态（Soft state）<br></li><li>最终一致（Eventually consistent）<br></li></ol><p><strong>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</strong>。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p><p>##分布式+集群简介</p><p><strong>分布式系统（distributed system）</strong><br><br> 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。</p><p>简单来讲：<br></p><ol><li>分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。<br></li><li>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。<br></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://oxtprvhvb.bkt.clouddn.com/nosql.jpg&quot; alt=&quot;post-cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;NOSQL入门&quot;&gt;&lt;a href=&quot;#NOSQL入门&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="NOSQL" scheme="http://michaelwwx.top/categories/NOSQL/"/>
    
    
      <category term="Redis NOSQL" scheme="http://michaelwwx.top/tags/Redis-NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="http://michaelwwx.top/2016/08/12/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://michaelwwx.top/2016/08/12/Volatile关键字/</id>
    <published>2016-08-12T01:28:29.000Z</published>
    <updated>2017-10-15T08:46:03.602Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/javase.jpg" alt="post-cover"><br>背景：Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了同步块和volatile关键字机制。<br>Java内存模型<br>Java内存模型规定了所有的变量都存储在主存中，每条线程中有自己的工作内存，线程中的工作内存中保存了该线程所使用的变量（这些变量是从主存中拷贝而来）<br>线程对变量的所有操作都必须在工作内存中进行。不同线程之间无法直接访问对方工作内存中变量，线程变量值的传递均需要通过主内存来完成。</p><p>如图：Java内存模型：<br><img src="/2016/08/12/Volatile关键字/volatile.png" alt=""></p><p>Java并发编程三点要求：<br>原子性<br>有序性<br>可见性<br>一.原子性  </p><p>二.有序性<br>定义：即程序执行随着代码顺序而执行。</p><p>但是在程序执行的时候，为了提高执行效率，虚拟机会进行指令重排序已追求更高效率。重排序对单线程没有影响，也不会影响最终的结果，但其对多线程环境下的结果可能会产生影响，所以为了确保最终结果的正确性，我们就需要禁止重排序。<br>解决办法：JVM中对Java代码有个happened-before原则和使用volatile关键字确保了不会进行指令重排序继而保证有序性。</p><p>三.可见性<br>定义：当多个线程去访问同一个变量时，某个线程对变量执行修改后，其余线程会立刻看到修改的变量。<br>概述：<br>例如：<br>线程1执行的代码：<br>Int i=0;<br>I=10;</p><p>线程2执行的代码：<br>J=i;</p><p>结果为：J=0；</p><p>解决：当一个共享变量被volatile修饰时，他会保证修改的值立即被更新到主存，当有其他线程需要读取时，他会去主存中读取新值。<br>另外还可以通过synchronized和lock能保证同一时刻只用一个线程获取锁然后执行同步代码，并且在释放锁之前会对变量的修改刷新到主存中，因此可以保证可见性。</p><p>总结；<br>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在jvm底层volatile是采用“内存屏障”来实现的。</p><p>一旦一个共享变量（类的成员变量，类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>保证了不同线程对这个变量进行操作时的可见性。<br>禁止进行指令重排序—–保证了有序性<br>注意：volatile不能保证原子性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://oxtprvhvb.bkt.clouddn.com/javase.jpg&quot; alt=&quot;post-cover&quot;&gt;&lt;br&gt;背景：Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了同步块和volatile关键字机制。&lt;br&gt;Ja
      
    
    </summary>
    
      <category term="JavaSe" scheme="http://michaelwwx.top/categories/JavaSe/"/>
    
    
      <category term="JavaSe 内存" scheme="http://michaelwwx.top/tags/JavaSe-%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
</feed>
