<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[TestMusicNotAuto]]></title>
      <url>/2017/10/15/TestMusicNotAuto/</url>
      <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=474567580&auto=1&height=66"></iframe>]]></content>
      
        
        <tags>
            
            <tag> Music </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TestMusic]]></title>
      <url>/2017/10/15/TestMusic/</url>
      <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27890306&auto=1&height=66"></iframe>

]]></content>
      
        
        <tags>
            
            <tag> Music </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[videoTest]]></title>
      <url>/2017/10/15/videoTest/</url>
      <content type="html"><![CDATA[<video src="http://oxtprvhvb.bkt.clouddn.com/TestVideo.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"><br>your browser does not support the video tag<br></video>

<p>作者：喵小哥<br>链接：<a href="https://www.zhihu.com/question/32460086/answer/154236302" target="_blank" rel="external">https://www.zhihu.com/question/32460086/answer/154236302</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><img src="http://oxtprvhvb.bkt.clouddn.com/1.png" alt="七牛图片"></p>
]]></content>
      
        
        <tags>
            
            <tag> Test </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[category]]></title>
      <url>/2017/10/15/category/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/15/category/category.jpg" alt="post-cover"><br>测试类别条目是否工作正常</p>
]]></content>
      
        
        <tags>
            
            <tag> 类别功能测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bootStrap]]></title>
      <url>/2017/10/14/bootStrap/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/14/bootStrap/a.jpg" alt="post-cover"></p>
<p>Bootstrap是比较流行的响应式框架,它会根据你的屏幕的大小来调整HTML元素的大小 —— 强调 响应式设计的概念。<br>通过响应式设计，你无需再为你的网站设计一个手机版的。它在任何尺寸的屏幕上看起来都会不错。</p>
]]></content>
      
        <categories>
            
            <category> BootStrap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BootStrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis缓存上]]></title>
      <url>/2017/10/14/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8A/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/14/Mybatis缓存上/mybatis.jpg" alt="post-cover"><br>Mybatis的缓存机制</p>
<p>前言：</p>
<p>Mybatis包含一个非常强大的查询缓存特性，他可以非常方便的配置和定制。缓存可以极大的提升查询效率。</p>
<p>Mybatis系统和Hibernate系统类似中定义了两级缓存：</p>
<p>一级缓存和二级缓存。</p>
<p>一级缓存（本地缓存），是基于SqlSession级别的缓存，默认情况下，一级缓存是开启的。<br>二级缓存（全局缓存），是基于nameSpace级别的缓存，二级缓存需要手动开启和配置。<br>       为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存。</p>
<p>一.一级缓存（local cache）</p>
<p>阅读mybatis源文档总结：<br>（1）一级缓存，即本地缓存，作用域为SqlSession，当Session flush或close后，该Session中的所有Cache将被清空。<br>（2）同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map中，Key：hashCode+查询的SqlId+编写的Sql查询语句+参数<br>（3）一级缓存失效的四种情况<br>        —–不同的SqlSession对于不同的一级缓存。<br>        ——同一个SqlSession但是查询条件不同。<br>        ——同一个SqlSession查询期间执行了一次增删改操作。<br>        ——同一个SqlSession两次查询期间手动清空了缓存。<br>1.1证明一级缓存的存在</p>
<p>案例：在同一个SqlSession中查询同一个id的Emp对象。</p>
<pre><code>@Test
public void TestFirstLevelCache() throws IOException
{
    SqlSession openSession=this.getSqlSessionFactory().openSession();
    try {
        EmpMapper empMapper=openSession.getMapper(EmpMapper.class);
        Emp emp=empMapper.findEmpById(4);
        Emp emp2=empMapper.findEmpById(4);
        System.out.println(emp);
        System.out.println(emp2);
        System.out.println(emp==emp2);
    } catch (Exception e) {
        e.printStackTrace();
    }
    finally{
        openSession.close();
    }
}
</code></pre><p>结果</p>
<p>分析：两条查询语句，只发送了一次sql语句，并且两次查询到封装的对象相同，说明第二次查询是从缓存中拿到的。证明了SqlSession级别的缓存存在。</p>
<p>1.2一级缓存失效的情况</p>
<p>一级缓存失效的四种情况<br>        —–不同的SqlSession对于不同的一级缓存。<br>        ——同一个SqlSession但是查询条件不同。<br>        ——同一个SqlSession查询期间执行了一次增删改操作。<br>        ——同一个SqlSession两次查询期间手动清空了缓存。</p>
<p>二.二级缓存</p>
<p>二级缓存，全局作用域缓存，二级缓存默认不开启，需要手动配置，Mybatis提供了二级缓存接口Cache以及实现。<br>生效：二级缓存只有在SqlSession关闭或提交之后才会生效。<br>原理：在开启了二级缓存的前提下，在一级缓存关闭以后，里面的缓存数据会迁移到二级缓存中。供程序使用。</p>
<p>2.1使用步骤</p>
<p>（1）在Mybatis全局配置文件的<settings>节点中配置</settings></p>
<p><setting name="cacheEnabled" value="true"><br>（2）在相应的Mapper.xml文件中加上<br> <cache eviction="" flushinterval="" readonly size="" type=""></cache><br> 或<cache-ref namespace=""></cache-ref></setting></p>
<p>cache标签中的属性：</p>
<p>eviction：缓存回收策略，默认是LRU<br>—LRU—最近最少使用：移除最长时间不被使用的对象。<br>—FIFO–先进先出：按对象加入缓存的顺序来移除它们。<br>—SOFT-软引用：移除基于垃圾回收期状态和软引用规则的对象。<br>—WEAK-弱引用：更积极的移除基于垃圾收集器和弱引用规则的对象。<br>flushInteval：刷新间隔，单位毫秒<br>    默认情况下不设置，即没有刷新间隔，缓存仅仅调用语句时刷新。<br>size：引用数目，正整数<br>—代表缓存最多可以存储多少个对象。<br>readOnly：只读，true/false，默认false<br>—true：只读缓存，会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改。速度快。<br>—false：读写缓存，会利用序列化和反序列来返回缓存对象的拷贝，速度较只读缓存慢，优点是安全。注意，这也就是为什么pojo对象需要实现序列化接口的原因。<br>type:用于自定义缓存类的全类名。</p>
<p>参照缓存cache-ref中的属性：<br>若想要在命名空间中共享相同的缓存配置，可以使用cache-ref元素来引用另外一个缓存。<br>namespace：表示引用哪个namespace的二级缓存，就将值设置为另外一个缓存的Mapper对象的全类名。</p>
<p>（3）对相应的Pojo对象实现序列化接口。这个与Cache标签中的readOnly属性的false值相关。</p>
<p>（4）需要在相应的查询语句中加上  userCache=”true”属性。表示该select语句使用二级缓存。</p>
<p>2.2整合第三方二级缓存—EhCache</p>
<p>EhCache是一个纯java的进程内缓存框架，具有快速、精干等特点，同时也是Hibernate中默认的CacheProvider。<br>Mybatis定义了Cache接口方便我们进行自定义扩展。</p>
<p>步骤：<br>（1）导入Ehcache包，整合Mybatis的jar包，日志包<br> ehcache=core-<em>.jar、mybatis-ehcache-</em>.jar、sl4j-api-<em>.jar、slf4j-log4j-</em>.jar</p>
<p>（2）编写ehcache.xml,具体可以到Ehcache官网上查看相关文档。</p>
<p>ehcache.xml</p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nonamespaceschemalocation="../config/ehcache.xsd"><br> <!-- 磁盘保存路径 --><br> <diskstore path="D:\ehcache"><br><br> <defaultcache maxelementsinmemory="10000" maxelementsondisk="10000000" eternal="false" overflowtodisk="true" timetoidleseconds="120" timetoliveseconds="120" diskexpirythreadintervalseconds="120" memorystoreevictionpolicy="LRU"><br> </defaultcache><br></diskstore></ehcache>

<!-- 
属性说明：
l diskStore：指定数据在磁盘中的存储位置。
l defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略

以下属性是必须的：
l maxElementsInMemory - 在内存中缓存的element的最大数目 
l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大
l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断
l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上

以下属性是可选的：
l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大
l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大
 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.
l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。
l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作
l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）
 -->
<p>（3）配置Mapper.xml中的Cache标签中的type属性，该属性的值为</p>
<p><cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache><br>同样可以配置参照缓存。</p>
<p>由于Mybatis内容很多，后面会继续更新Mybatis各方面的知识，包括Mybatis原理，Mybatis架构，Mybatis和Redis，memcache的整合等等。<br>本文是源码级别学习Mybatis系列的一节，如果您有兴趣，可以继续关注我哟，如果觉得本文不错，顺手点个赞吧，您的鼓励，是我继续分享知识的强大动力！<br>如果您觉得有不妥或者错误的地方，还请您不吝指教！</p>
]]></content>
      
        <categories>
            
            <category> Mybatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis Cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NewBlog]]></title>
      <url>/2017/10/14/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/14/博客测试图片/a.jpg" alt="post-cover"><br>阿什顿发发顺丰就爱了就爱上江东父老</p>
]]></content>
      
        <categories>
            
            <category> 测试category </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Volatile关键字]]></title>
      <url>/2016/08/12/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/javase.jpg" alt="post-cover"><br>背景：Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了同步块和volatile关键字机制。<br>Java内存模型<br>Java内存模型规定了所有的变量都存储在主存中，每条线程中有自己的工作内存，线程中的工作内存中保存了该线程所使用的变量（这些变量是从主存中拷贝而来）<br>线程对变量的所有操作都必须在工作内存中进行。不同线程之间无法直接访问对方工作内存中变量，线程变量值的传递均需要通过主内存来完成。</p>
<p>如图：Java内存模型：<br><img src="/2016/08/12/Volatile关键字/volatile.png" alt=""></p>
<p>Java并发编程三点要求：<br>原子性<br>有序性<br>可见性<br>一.原子性  </p>
<p>二.有序性<br>定义：即程序执行随着代码顺序而执行。</p>
<p>但是在程序执行的时候，为了提高执行效率，虚拟机会进行指令重排序已追求更高效率。重排序对单线程没有影响，也不会影响最终的结果，但其对多线程环境下的结果可能会产生影响，所以为了确保最终结果的正确性，我们就需要禁止重排序。<br>解决办法：JVM中对Java代码有个happened-before原则和使用volatile关键字确保了不会进行指令重排序继而保证有序性。</p>
<p>三.可见性<br>定义：当多个线程去访问同一个变量时，某个线程对变量执行修改后，其余线程会立刻看到修改的变量。<br>概述：<br>例如：<br>线程1执行的代码：<br>Int i=0;<br>I=10;</p>
<p>线程2执行的代码：<br>J=i;</p>
<p>结果为：J=0；</p>
<p>解决：当一个共享变量被volatile修饰时，他会保证修改的值立即被更新到主存，当有其他线程需要读取时，他会去主存中读取新值。<br>另外还可以通过synchronized和lock能保证同一时刻只用一个线程获取锁然后执行同步代码，并且在释放锁之前会对变量的修改刷新到主存中，因此可以保证可见性。</p>
<p>总结；<br>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在jvm底层volatile是采用“内存屏障”来实现的。</p>
<p>一旦一个共享变量（类的成员变量，类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>保证了不同线程对这个变量进行操作时的可见性。<br>禁止进行指令重排序—–保证了有序性<br>注意：volatile不能保证原子性。</p>
]]></content>
      
        <categories>
            
            <category> JavaSe </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSe 内存 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
