<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/11/01/%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/hello.jpg" alt="post-cover"></p>
<h1 id="总结记录第一次面试经历"><a href="#总结记录第一次面试经历" class="headerlink" title="总结记录第一次面试经历"></a>总结记录第一次面试经历</h1><blockquote>
<p>今天经历了人生中第一次面试，这也象征着我马上也要参加工作了，哈哈。俗话说，万事开头难，有了第一次的尝试相信后面会越来越好！<br>面试的公司在无锡，感觉里面环境很不错。填表后就开始了对公司的了解。<br>公司的培养体系，公司的晋升制度等等信息。公司福利很好，对于应届生不论实习还是工作都很好。<br>与以往朋友口中得知、网络上介绍的面试和自己心中的面试形式有很大不同，一般都是笔试、面试，面试问一些技术方面的问题。这次笔试题型也和做过的不一样，非常灵活，五题中选出1-2题认为理解最深刻的题目。<br></p>
<h2 id="笔试部分"><a href="#笔试部分" class="headerlink" title="笔试部分"></a>笔试部分</h2></blockquote>
<h3 id="第一部分JavaSE"><a href="#第一部分JavaSE" class="headerlink" title="第一部分JavaSE"></a>第一部分JavaSE</h3><blockquote>
<ol>
<li>javase基础—这部分问题不是很大<br></li>
<li>jvm       —jvm类加载啥的倒还理解，参数之前也专门学习过，可是考试的时候就忘记了。<br></li>
<li>多线程（多线程居然放在一个模块）<br><br>这部分确实很重要，平时使用的都是api，对底层的研究还是不够,有的理解的不全就没有写。记得有一题是线程安全部分，这一部分是专门研究过的，也有之前在群里要管理被群友问到过，可是确实不太好描述，在<java并发编程实战>这本书中的描述是：当多个线程访问某个类时，不管运行时环境采用何种调用方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都表现出正确的行为，则成这个类时线程安全的。<br>想起来了，还有一个问题是String为什么是final修饰？<br>回答的是String不可变性，感觉有点不对题。<br>已经购买《Java并发编程》来啃<br>###第二部分：数据库###<br>考察的主要是基本的sql语句；这些题目在学数据库导论的时候做过。还是缺少回顾。</java并发编程实战></li>
</ol>
</blockquote>
<p>###第三部分：JavaScript###</p>
<blockquote>
<p>考察的比较细，对js的语法和特性要求较高。平时只会使用基本的ajax，jquery筛选、修改等操作。对js的学习并不是很深。</p>
</blockquote>
<p>##面试部分##</p>
<blockquote>
<p>面试部分采用的是群面，可能是应聘的人比较多的缘故吧，四个人一组群面。有点紧张，一直感觉就像老师和学生之间的关系。不过面试官很好，比较平和，秉承互联网公司的open思想让我们交流，还有个兄弟比我还紧张。<br>主要问的就是一些生活中的问题，可能因为大家都没有太多工作经验的缘故吧，问技术可能也只是点到为止。所以面试全程面试官都没有面技术。想起来高中老班说的先做人，再做事，到社会上也是一样的。技术只是其中的一部分，更多的是思维，为人处世。</p>
</blockquote>
<p>##总结##</p>
<blockquote>
<p>总的来说，这次面试并不理想，主要还是准备不重复，但是知道了努力的方向,要善于思考，善于总结，就和面试官讲的需要，还有一部分是源于平时对高新技术的追求过多，而对有些基础知识确实浅尝而止，总以为开发中很少用到。已经入手《Thinking in java》和《java并发编程》。<br><br>脚踏实地。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM浅析]]></title>
      <url>/2017/11/01/JVM/</url>
      <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD.jpg" alt="post-cover"></p>
<h2 id="垃圾回收的概念："><a href="#垃圾回收的概念：" class="headerlink" title="垃圾回收的概念："></a>垃圾回收的概念：</h2><blockquote>
<p>在jvm中，堆内存和垃圾回收器这两个部分和垃圾回收相关。堆内存是运行时用来存储实例对象和数据的空间。垃圾回收只运行在堆区上。</p>
<p>在堆区和对象空间，把对象根据存活的周期，把对象分成3部分。<br></p>
<ol>
<li>年轻代<br></li>
<li>老年代<br></li>
<li>永久代<br><br><strong>对象被回收的规则：当一个对象不被引用了，那么它就是可以被回收的对象。</strong></li>
</ol>
<p><code></code></p>
<ul>
<li>public static void main(String[]args) {<br><br>String s1=”a”;//“a”被s1所依赖，s1被栈区所依赖<br><br>String s2=”b”;//s1已经从栈区弹出，这时”a”已经无人引用，”a”已经可以被回收<br><br>String s3=”c”;<br>}<br><br><br>eden<br><br>s0<br><br>s1<br><br>tenured<br><br>permanent<br><br>年轻区<br><br>老年区<br><br>永久区<br><br>年轻区：<br></li>
</ul>
<ol>
<li><strong>Eden</strong>：所有的实例运行时最初的部分会分配到eden区。<br></li>
<li><strong>S0</strong>：eden区中经过一次垃圾回收之后依然存活的对象，会被转移到s0区<br></li>
<li><strong>S1</strong>：s0区中再经过一次垃圾回收之后依然存活的对象，会被转移到s1区，如果s0满了，s1区也会转存一部分s0区的对象<br></li>
<li><strong>老年区</strong>：s0，s1几轮迭代后依然存活的对象。<br></li>
<li><strong>永久区</strong>：元数据，方法等等（jdk1.8中已经移除了永久区）<br></li>
</ol>
</blockquote>
<h2 id="垃圾回收机制："><a href="#垃圾回收机制：" class="headerlink" title="垃圾回收机制："></a>垃圾回收机制：</h2><blockquote>
<p>&emsp;&emsp;<strong>Java的垃圾回收是一个自动运行的管理程序，通过gc的自动执行，jvm将程序员从申请和释放内存的繁重操作中解放出来。</strong></p>
<p>&emsp;&emsp;GC是一个自动执行的进程，程序员不需要在代码中主动初始化gc。Java提供了System.gc<br>()方法请求jvm调用gc。GC提供给程序员调用gc的机会。但是，jvm在执行这条命令的时候，它只会把这条命令当作是一个建议。因此手动调用gc不能保证这些请求会真的执行垃圾回收。Jvm会根据对内存中的eden区的实际使用情况，做出决定。<br>Jvm的规范把执行的选择权留给了各个版本的jvm的具体实现。</p>
<p>&emsp;&emsp;<strong>垃圾回收的流程：</strong></p>
<ol>
<li>对象存放到eden区。</li>
<li>如果对象没有被回收，会放到s区。</li>
<li>如果对象在s区依然存活，则会放到t区。</li>
<li>在t区，对象失去引用，则最后会被回收。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;<strong>垃圾回收机制的各个区的详解：</strong></p>
<blockquote>
<p>Eden区：一个对象被创建的时候，它最初是被存放在堆内存的年轻代的eden区中。<br>S区（s0和s1）：eden区中的对象被回收过几轮之后，还存活的部分，会被从eden区转移到s0区。S0的对象回收过几轮之后，会被转移到s1区。<br>无用的对象会被立刻被打上标记，垃圾回收会根据标记来决定对象是继续留在原地，还是被转移到其他区或者是被回收。<br>O：老年代或者永久区的对象遵循的是另一套逻辑。当gc扫描年轻代区域的时候，s1区中的还活着的对象会被放到O区中。S1区中没有被应用的对象，会被立即删除。<br>Mayor GC：在java垃圾回收的最后一个阶段，如果发现对象没有任何引用，对象会被立即删除。</p>
<p>&emsp;&emsp;从上可以看出，生存周期越长的对象，被gc扫描的频率就越低。<br>碎片的概念：<br>一旦实例在堆区中被删除，它们原来的位置就空出来以供后面的对象使用。但是这些闲暇空间的操作，必然会产生很多空隙，这些空隙就是内存碎片。<br>为了更快更有效率的重新利用内存，就需要对内存做去碎片化操作，此操作是由GC完成。根据不同的GC的策略，被回收的内存会被独立的内存压缩程序所整合。</p>
</blockquote>
<p>&emsp;&emsp;<strong>Java中提供了4种垃圾回收器</strong>：<br></p>
<ol>
<li>Serial Garbage Collector：顺序回收<br></li>
<li>Parallel Garbage Collector：并行回收<br></li>
<li>CMS Garbage Collector：并发标记回收<br></li>
<li>G1 Garbage Collector：网格化回收</li>
</ol>
<blockquote>
<p>Serial Garbage Collector：它是为但线程场景设计，只使用一个线程。它启动的时候会暂停所有应用线程。它适合简单的命令行程序。<br>使用-XX:+UseSerialGC参数</p>
<p>Parallel Garbage Collector：并发多线程垃圾回收器。它是jvm的默认回收器。与Serial不同的是，它是使用多个线程来执行垃圾回收工作。它在执行垃圾回收的时候，也是需要暂停所有应用线程。</p>
<p>CMS Garbage Collector：并发标记回收（concurrent mark sweep），使用多个线程扫描对内存标记可以被回收的对象，清除标记对象。<br>CMS只在两种情况下需要暂停应用线程：<br></p>
<ol>
<li>在老年区中标记引用对象的时候<br></li>
<li>在做垃圾回收的时候，堆内存有变化<br><br>CMS比其他两种gc拥有更高的并发吞吐量，CMS需要占用更高的CPU性能。<br>使用-XX:+UsePalNewGC参数</li>
</ol>
<p>G1 Garbage Collector：G1垃圾回收器适用于更大的堆内存。它将内存划分成不同的区块，对各个区块分别进行回收工作。G1在回收空间之后会会立刻对堆空间的空闲空间进行整合。CMS也有内存整合，但需要停止所有线程后执行内存整合工作（STW，stop the<br>world）。而G1可以对不同的区间根据优先级进行整合。<br>使用-XX:+UseG1GC参数</p>
</blockquote>
<p><strong>JVM的优化参数：**</strong>本人第一次面试就考到了，建议各位学习一下相关参数以及其意义。(记不住没写出来，香菇)**</p>
<blockquote>
<p>1.-Xms：设置堆区的初始大小<br><br>2.-Xmx: 设置堆区的最大值<br><br>3.-Xmn: 设置年轻代的大小<br><br>4.-XX:PermSize:设置永久代的初始大小<br><br>5.-XX:MaxPermSize:设置永久代的最大值<br><br><strong>JVM参数实例：</strong><br>java&emsp; –Xms10m&emsp; –Xmx100m &emsp;–Xmn1m&emsp; -XX:PermSize20m&emsp; -XX:MaxPermSize20m&emsp; -XX:+UseSerialGC JavaApp<br><br>–</p>
</blockquote>
<p><strong>java的垃圾判断和回收托管的特征：</strong></p>
<blockquote>
<p>GC什么时候会回收一个对象呢？<br></p>
<ol>
<li>对象没有引用<br></li>
<li>作用域发生了未被捕获的异常<br></li>
<li>程序在作用域正常结束<br></li>
<li>程序运行了System.exit(0);<br></li>
<li>程序意外终止（被杀进程等等）<br></li>
</ol>
</blockquote>
<p><strong>Jvm的内存泄漏：**</strong>面试中考到过！！！**<br></p>
<blockquote>
<ol>
<li>循环引用（1.2之后就被解决了）<br></li>
<li>调用对象和被调用对象的生命周期不一致（良好的编程习惯）<br></li>
<li>gc在执行回收操作的时候发生异常，这个异常往往是重写finalize方法引发的。<br></li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bootStrap]]></title>
      <url>/2017/10/14/bootStrap/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/14/bootStrap/a.jpg" alt="post-cover"></p>
<p>Bootstrap是比较流行的响应式框架,它会根据你的屏幕的大小来调整HTML元素的大小 —— 强调 响应式设计的概念。<br>通过响应式设计，你无需再为你的网站设计一个手机版的。它在任何尺寸的屏幕上看起来都会不错。</p>
]]></content>
      
        <categories>
            
            <category> BootStrap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BootStrap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis缓存上]]></title>
      <url>/2017/10/14/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8A/</url>
      <content type="html"><![CDATA[<p><img src="/2017/10/14/Mybatis缓存上/mybatis.jpg" alt="post-cover"><br>Mybatis的缓存机制</p>
<p>前言：</p>
<p>Mybatis包含一个非常强大的查询缓存特性，他可以非常方便的配置和定制。缓存可以极大的提升查询效率。</p>
<p>Mybatis系统和Hibernate系统类似中定义了两级缓存：</p>
<p>一级缓存和二级缓存。</p>
<p>一级缓存（本地缓存），是基于SqlSession级别的缓存，默认情况下，一级缓存是开启的。<br>二级缓存（全局缓存），是基于nameSpace级别的缓存，二级缓存需要手动开启和配置。<br>       为了提高扩展性，Mybatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存。</p>
<p>一.一级缓存（local cache）</p>
<p>阅读mybatis源文档总结：<br>（1）一级缓存，即本地缓存，作用域为SqlSession，当Session flush或close后，该Session中的所有Cache将被清空。<br>（2）同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map中，Key：hashCode+查询的SqlId+编写的Sql查询语句+参数<br>（3）一级缓存失效的四种情况<br>        —–不同的SqlSession对于不同的一级缓存。<br>        ——同一个SqlSession但是查询条件不同。<br>        ——同一个SqlSession查询期间执行了一次增删改操作。<br>        ——同一个SqlSession两次查询期间手动清空了缓存。<br>1.1证明一级缓存的存在</p>
<p>案例：在同一个SqlSession中查询同一个id的Emp对象。</p>
<pre><code>@Test
public void TestFirstLevelCache() throws IOException
{
    SqlSession openSession=this.getSqlSessionFactory().openSession();
    try {
        EmpMapper empMapper=openSession.getMapper(EmpMapper.class);
        Emp emp=empMapper.findEmpById(4);
        Emp emp2=empMapper.findEmpById(4);
        System.out.println(emp);
        System.out.println(emp2);
        System.out.println(emp==emp2);
    } catch (Exception e) {
        e.printStackTrace();
    }
    finally{
        openSession.close();
    }
}
</code></pre><p>结果</p>
<p>分析：两条查询语句，只发送了一次sql语句，并且两次查询到封装的对象相同，说明第二次查询是从缓存中拿到的。证明了SqlSession级别的缓存存在。</p>
<p>1.2一级缓存失效的情况</p>
<p>一级缓存失效的四种情况<br>        —–不同的SqlSession对于不同的一级缓存。<br>        ——同一个SqlSession但是查询条件不同。<br>        ——同一个SqlSession查询期间执行了一次增删改操作。<br>        ——同一个SqlSession两次查询期间手动清空了缓存。</p>
<p>二.二级缓存</p>
<p>二级缓存，全局作用域缓存，二级缓存默认不开启，需要手动配置，Mybatis提供了二级缓存接口Cache以及实现。<br>生效：二级缓存只有在SqlSession关闭或提交之后才会生效。<br>原理：在开启了二级缓存的前提下，在一级缓存关闭以后，里面的缓存数据会迁移到二级缓存中。供程序使用。</p>
<p>2.1使用步骤</p>
<p>（1）在Mybatis全局配置文件的<settings>节点中配置</settings></p>
<p><setting name="cacheEnabled" value="true"><br>（2）在相应的Mapper.xml文件中加上<br> <cache eviction="" flushinterval="" readonly size="" type=""></cache><br> 或<cache-ref namespace=""></cache-ref></setting></p>
<p>cache标签中的属性：</p>
<p>eviction：缓存回收策略，默认是LRU<br>—LRU—最近最少使用：移除最长时间不被使用的对象。<br>—FIFO–先进先出：按对象加入缓存的顺序来移除它们。<br>—SOFT-软引用：移除基于垃圾回收期状态和软引用规则的对象。<br>—WEAK-弱引用：更积极的移除基于垃圾收集器和弱引用规则的对象。<br>flushInteval：刷新间隔，单位毫秒<br>    默认情况下不设置，即没有刷新间隔，缓存仅仅调用语句时刷新。<br>size：引用数目，正整数<br>—代表缓存最多可以存储多少个对象。<br>readOnly：只读，true/false，默认false<br>—true：只读缓存，会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改。速度快。<br>—false：读写缓存，会利用序列化和反序列来返回缓存对象的拷贝，速度较只读缓存慢，优点是安全。注意，这也就是为什么pojo对象需要实现序列化接口的原因。<br>type:用于自定义缓存类的全类名。</p>
<p>参照缓存cache-ref中的属性：<br>若想要在命名空间中共享相同的缓存配置，可以使用cache-ref元素来引用另外一个缓存。<br>namespace：表示引用哪个namespace的二级缓存，就将值设置为另外一个缓存的Mapper对象的全类名。</p>
<p>（3）对相应的Pojo对象实现序列化接口。这个与Cache标签中的readOnly属性的false值相关。</p>
<p>（4）需要在相应的查询语句中加上  userCache=”true”属性。表示该select语句使用二级缓存。</p>
<p>2.2整合第三方二级缓存—EhCache</p>
<p>EhCache是一个纯java的进程内缓存框架，具有快速、精干等特点，同时也是Hibernate中默认的CacheProvider。<br>Mybatis定义了Cache接口方便我们进行自定义扩展。</p>
<p>步骤：<br>（1）导入Ehcache包，整合Mybatis的jar包，日志包<br> ehcache=core-<em>.jar、mybatis-ehcache-</em>.jar、sl4j-api-<em>.jar、slf4j-log4j-</em>.jar</p>
<p>（2）编写ehcache.xml,具体可以到Ehcache官网上查看相关文档。</p>
<p>ehcache.xml</p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nonamespaceschemalocation="../config/ehcache.xsd"><br> <!-- 磁盘保存路径 --><br> <diskstore path="D:\ehcache"><br><br> <defaultcache maxelementsinmemory="10000" maxelementsondisk="10000000" eternal="false" overflowtodisk="true" timetoidleseconds="120" timetoliveseconds="120" diskexpirythreadintervalseconds="120" memorystoreevictionpolicy="LRU"><br> </defaultcache><br></diskstore></ehcache>

<!-- 
属性说明：
l diskStore：指定数据在磁盘中的存储位置。
l defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略

以下属性是必须的：
l maxElementsInMemory - 在内存中缓存的element的最大数目 
l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大
l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断
l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上

以下属性是可选的：
l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大
l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大
 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.
l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。
l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作
l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）
 -->
<p>（3）配置Mapper.xml中的Cache标签中的type属性，该属性的值为</p>
<p><cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache><br>同样可以配置参照缓存。</p>
<p>由于Mybatis内容很多，后面会继续更新Mybatis各方面的知识，包括Mybatis原理，Mybatis架构，Mybatis和Redis，memcache的整合等等。<br>本文是源码级别学习Mybatis系列的一节，如果您有兴趣，可以继续关注我哟，如果觉得本文不错，顺手点个赞吧，您的鼓励，是我继续分享知识的强大动力！<br>如果您觉得有不妥或者错误的地方，还请您不吝指教！</p>
]]></content>
      
        <categories>
            
            <category> Mybatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis Cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nosql数据库入门]]></title>
      <url>/2017/08/09/Redis/</url>
      <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/nosql.jpg" alt="post-cover"></p>
<h1 id="NOSQL入门"><a href="#NOSQL入门" class="headerlink" title="NOSQL入门"></a>NOSQL入门</h1><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>###单机MySQL的时代</p>
<blockquote>
<ol>
<li><p>数据量的总大小一个服务器存不下。</p>
</li>
<li><p>数据的索引（B+Tree）空间太大。</p>
</li>
<li><p>访问量（读写混合）一个实例不能承受。<br>###Memcached（缓存)+MySQL+垂直拆分<br>发展：随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注于功能上，同时也在追求性能。这时缓存技术的出现有效的缓解了数据库的压力。优化数据库的结构和所有。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大时，多台web机器通过文件缓存不能共享，大量的小文件缓存带来了比较高的IO压力，这是Memcached就自然的成为了非常时尚的技术产品。<br>Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少服务器导致重新hash带来的大量缓存失效的弊端。</p>
</li>
</ol>
</blockquote>
<p>###MySQL主从读写分离</p>
<blockquote>
<p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。<br>MySQL的master-slav模式成为这个时候的网站标配。</p>
</blockquote>
<p>###分表分库+水平拆分+MySQL集群</p>
<blockquote>
<p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。<br>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大<br>的保证。</p>
</blockquote>
<p>###MySQL的扩展性瓶颈</p>
<blockquote>
<p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p>
</blockquote>
<p>###这个时候NOSQL的概念提出</p>
<blockquote>
<p>为什么使用NoSQL ?<br>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
</blockquote>
<p>#NOSQL的介绍</p>
<p>##NOSQL是什么？</p>
<blockquote>
<p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，<br>泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p>
<p>（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
</blockquote>
<p>##NOSQL能干嘛?</p>
<p>###易扩展</p>
<blockquote>
<p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
<p>###大数据量高性能</p>
<p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。<br>这得益于它的无关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</p>
<p>###多种灵活的数据模型<br>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，<br>增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</p>
<p>###传统RDBMS  VS  NOSQL</p>
<p><strong>RDBMS</strong><br></p>
<ol>
<li>高度组织化结构化数据<br></li>
<li>结构化查询语言（SQL）<br></li>
<li>数据和关系都存储在单独的表中。<br></li>
<li>数据操纵语言，数据定义语言<br></li>
<li>严格的一致性<br></li>
<li>基础事务<br></li>
</ol>
<p><strong>NoSQL</strong><br></p>
<ol>
<li>代表着不仅仅是SQL<br></li>
<li>没有声明性查询语言<br></li>
<li>没有预定义的模式<br></li>
<li>键 - 值对存储，列存储，文档存储，图形数据库<br></li>
<li>最终一致性，而非ACID属性<br></li>
<li>非结构化和不可预知的数据<br></li>
<li>CAP定理<br></li>
<li>高性能，高可用性和可伸缩性<br></li>
</ol>
</blockquote>
<p>##NOSQL数据库的3V+3高</p>
<blockquote>
<p><strong>3V</strong><br><br>大数据时代的3v<br></p>
<ol>
<li>海量Volume<br></li>
<li>多样Variety<br></li>
<li>实时Velocity<br></li>
</ol>
<p><strong>3高</strong><br></p>
<ol>
<li>高并发<br></li>
<li>高可扩<br></li>
<li>高性能<br></li>
</ol>
</blockquote>
<p>#NOSQL数据库的分类</p>
<p>##KV键值<br>典型介绍<br></p>
<ol>
<li>新浪：BerkeleyDB+redis<br></li>
<li>美团：redis+tair<br></li>
<li>阿里、百度：Memcache+redis<br></li>
</ol>
<p>##文档型数据库（bson格式比较多）<br>典型介绍：MongoDB</p>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>##列存储数据库<br>Cassandra、HBASE<br><br>分布式文件系统</p>
<p>##图关系数据库<br>注意：图关系数据不是放图形的，放的是关系，比如朋友圈社交网络，广告推荐系统。<br><br>典型：Neo4j，infoGrid</p>
<p>#分布式数据库中CAP原理+BASE</p>
<p>##关系型数据库的ACID<br></p>
<ol>
<li>A:Atomicity原子性<br></li>
<li>C:Consistency一致性<br></li>
<li>I:Isolation独立性<br></li>
<li>D：Durability持久性<br><br>##分布式数据CAP原理：</li>
<li>C:Consistency（强一致性）</li>
<li>A：Availablity（可用性）</li>
<li>P:Partition tolerance（分区容错性）</li>
</ol>
<p>###CAP的3进2<br>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。<br>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<strong>分区容忍性</strong>是我们必须需要实现的</p>
<p>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。<br></p>
<ol>
<li>CA 传统Oracle数据库<br></li>
<li>AP 大多数网站架构的选择<br></li>
<li>CP Redis、Mongodb<br></li>
</ol>
<p>注意：分布式架构的时候必须做出取舍。<br>一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。<br>因此牺牲C换取P，这是目前分布式数据库产品的方向</p>
<p>一致性与可用性的决择<br>对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p>
<p>####数据库事务一致性需求<br>　　很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</p>
<p>####数据库的写实时性和读实时性需求<br>　　对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p>
<p>####对复杂的SQL查询，特别是多表关联查询的需求<br>　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>
<p>##BASE<br>BASE是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>BASE其实是下面三个术语的缩写：<br></p>
<ol>
<li>基本可用（Basically Available）<br></li>
<li>软状态（Soft state）<br></li>
<li>最终一致（Eventually consistent）<br></li>
</ol>
<p><strong>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观</strong>。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<p>##分布式+集群简介</p>
<p><strong>分布式系统（distributed system）</strong><br><br> 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。</p>
<p>简单来讲：<br></p>
<ol>
<li>分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。<br></li>
<li>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。<br></li>
</ol>
]]></content>
      
        <categories>
            
            <category> NOSQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis NOSQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volatile关键字]]></title>
      <url>/2016/08/12/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p><img src="http://oxtprvhvb.bkt.clouddn.com/javase.jpg" alt="post-cover"><br>背景：Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了同步块和volatile关键字机制。<br>Java内存模型<br>Java内存模型规定了所有的变量都存储在主存中，每条线程中有自己的工作内存，线程中的工作内存中保存了该线程所使用的变量（这些变量是从主存中拷贝而来）<br>线程对变量的所有操作都必须在工作内存中进行。不同线程之间无法直接访问对方工作内存中变量，线程变量值的传递均需要通过主内存来完成。</p>
<p>如图：Java内存模型：<br><img src="/2016/08/12/Volatile关键字/volatile.png" alt=""></p>
<p>Java并发编程三点要求：<br>原子性<br>有序性<br>可见性<br>一.原子性  </p>
<p>二.有序性<br>定义：即程序执行随着代码顺序而执行。</p>
<p>但是在程序执行的时候，为了提高执行效率，虚拟机会进行指令重排序已追求更高效率。重排序对单线程没有影响，也不会影响最终的结果，但其对多线程环境下的结果可能会产生影响，所以为了确保最终结果的正确性，我们就需要禁止重排序。<br>解决办法：JVM中对Java代码有个happened-before原则和使用volatile关键字确保了不会进行指令重排序继而保证有序性。</p>
<p>三.可见性<br>定义：当多个线程去访问同一个变量时，某个线程对变量执行修改后，其余线程会立刻看到修改的变量。<br>概述：<br>例如：<br>线程1执行的代码：<br>Int i=0;<br>I=10;</p>
<p>线程2执行的代码：<br>J=i;</p>
<p>结果为：J=0；</p>
<p>解决：当一个共享变量被volatile修饰时，他会保证修改的值立即被更新到主存，当有其他线程需要读取时，他会去主存中读取新值。<br>另外还可以通过synchronized和lock能保证同一时刻只用一个线程获取锁然后执行同步代码，并且在释放锁之前会对变量的修改刷新到主存中，因此可以保证可见性。</p>
<p>总结；<br>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在jvm底层volatile是采用“内存屏障”来实现的。</p>
<p>一旦一个共享变量（类的成员变量，类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>保证了不同线程对这个变量进行操作时的可见性。<br>禁止进行指令重排序—–保证了有序性<br>注意：volatile不能保证原子性。</p>
]]></content>
      
        <categories>
            
            <category> JavaSe </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSe 内存 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
